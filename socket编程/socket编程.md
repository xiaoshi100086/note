### TIME_WAIT

一种特殊的tcp状态，当四次挥手后，主动方最后发出ack包时，需要等待2MSL时长的状态。经过2MSL后，tcp进入CLOSED状态。

作用：

1. 防止ack出现丢失，这时被动方会重新发送fin包。为了再接受该报并重发ACK，主动方必须等待2MSL时长
2. 防止旧连接的报文发到新连接的一端。如果四次挥手后再立即重建连接，可能还存在旧连接的报文在网络中游荡，并最终发给新连接的一端

MSL，Maximum Segment Lifetime，最大报文段生成时间，是指tcp报文期望会在网络中存在的最大时间。因为tcp报文是基于ip数据报在网络中传输的，ip是根据ttl(Time To Live 生存时间)跳数来丢弃报文的。所以tcp报文在网络中最大时间不可以准确估计，在linux中该MSL默认是60s。

问题：

1. 服务器会绑定众所周知的端口，当服务器启动，原有的连接会在服务器停止前主动关闭并最终处于TIME_WAIT状态。再次启动服务器，bind会报 Address already in use 问题

    原因：tcp限制连接处于TIME_WAIT时，不允许创建新的连接。linux的实现会更严格，socket不能使用处于TIME_WAIT连接的本地端口。

    解决：使用SO_REUSEADDR socket 选项，该选项允许多个socket使用通过本地端口

2. 频繁的关闭连接导致有大量的连接处于TIME_WAIT
   
   解决：

   1. 调小TIME_WAIT。不建议这样做，因为这个选项是全系统共用的。
   2. 使用异常关闭。通过使能linger，并设置退出时间为0来发送RESET包异常关闭连接，就不会有TIME_WAIT状态。如果你的程序这种也不建议主动关闭方使用，因为TIME_WAIT有着以上作用，而且正常关闭可以保证将缓存队列的数据进行发送
   3. 使用长连接，减少关闭次数。推荐
   4. 如果是服务端，建议由客户端主动关闭。推荐

### 给udp应用增加可靠性

udp数据报会在网络传输时丢失，如果想要增加可靠性，需要增加确认该包成功发送到服务器的逻辑。

这里的确认，就需要应答机制和序列号

如果长时间没有应答，就需要超时重传。这里超时阈值也需要动态设置，因为网络rtt(来回时间)是不稳定的，所以需要收集一段时间的rtt数据，进行估算。同时还需要指数退火算法来增加重试后的超时阈值，因为出现超时就说明网络rtt增大，所以需要增加阈值。重试超过一定次数则失败。

总结：
1. 请求应答机制
2. 序列号
3. 超时重试，超时阈值需要动态估算和重试指数增加

todo：tcp如何估算rtt

todo: shutdown